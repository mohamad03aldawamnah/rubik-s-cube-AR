<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Rubik's Cube AR</title>
    <link rel="stylesheet" href="style/index.css">
</head>
<script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
<script>
    AFRAME.registerComponent('rbscube-controller', {
        init: function () {
            let isAnimating = false; // Initially, no animation is in progress

            window.addEventListener('keydown', (event) => {
                if ((event.key === 'l' || event.key === 'L') && !isAnimating) {
                    isAnimating = true; // Set to animating when the animation starts

                    // Get the current rotation angles
                    let x = this.el.getAttribute('rotation').x;
                    let y = this.el.getAttribute('rotation').y;
                    let z = this.el.getAttribute('rotation').z;

                    // Set the target rotation angle and step for rotation
                    let targetY = y + 90;
                    let step = 5;
                    let interval = 10; // Update every 10 milliseconds

                    // Use setInterval to implement a smooth animation
                    let rotateInterval = setInterval(() => {
                        if (y < targetY) {
                            y += step;
                            this.el.setAttribute('rotation', { x: x, y: y, z: z });
                        } else {
                            clearInterval(rotateInterval); // Stop the animation when the target angle is reached
                            isAnimating = false; // Reset to allow keypress after animation finishes
                        }
                    }, interval);

                    console.log('Pressed Q  key!');
                }
            });
        },
    });
</script>
<script>
    AFRAME.registerComponent('cube-controller', {
        schema: {
            radius: { type: 'number', default: 1 },
            speed: { type: 'number', default: 180 }
        },

        init: function () {
            // 世界坐标系初始化
            this.worldYAxis = new THREE.Vector3(0, 1, 0);
            this.center = new THREE.Vector3(0, 0, 0);

            // 初始角度计算
            const pos = this.el.object3D.position;
            this.angle = Math.atan2(pos.z, pos.x);
            this.targetAngle = this.angle;

            // 状态初始化
            this.selfRotation = 0;
            this.isMoving = false;
            this.isTopLayer = false;
            this.isBottomLayer = false;

            this.validateRadius();
        },

        validateRadius: function() {
            const actual = Math.hypot(
                this.el.object3D.position.x,
                this.el.object3D.position.z
            );
            if (Math.abs(actual - this.data.radius) > 0.01) {
                console.warn(`半径校验失败: ${this.data.radius} vs ${actual.toFixed(2)}`);
            }
        },

        updateLayerStatus: function() {
            const cubes = Array.from(document.querySelectorAll('.cube'));
            const currentY = this.el.object3D.position.y;

            // 更新层级状态
            const allY = cubes.map(c => c.object3D.position.y);
            this.isTopLayer = (currentY === Math.max(...allY));
            this.isBottomLayer = (currentY === Math.min(...allY));
        },

        handleRotation: function(direction) {
            if (this.isMoving) return;
            const delta = direction * 90; // 正值为顺时针
            this.startRotation(delta);
        },

        startRotation: function(delta) {
            this.targetAngle = this.angle - THREE.MathUtils.degToRad(delta);
            this.isMoving = true;
        },

        tick: function(_, deltaTime) {
            if (!this.isMoving) return;

            const timeFactor = deltaTime / 1000;
            this.updateOrbit(timeFactor);
            this.updateSelfRotation(timeFactor);
            this.checkCompletion();
        },

        updateOrbit: function(timeFactor) {
            const step = THREE.MathUtils.degToRad(this.data.speed) * timeFactor;
            const remaining = this.targetAngle - this.angle;

            if (Math.abs(remaining) > step) {
                this.angle += Math.sign(remaining) * step;
            } else {
                this.angle = this.targetAngle;
            }

            this.el.object3D.position.set(
                this.center.x + this.data.radius * Math.cos(this.angle),
                this.el.object3D.position.y,
                this.center.z + this.data.radius * Math.sin(this.angle)
            );
        },

        updateSelfRotation: function(timeFactor) {
            const step = -Math.sign(this.targetAngle - this.angle) *
                Math.abs(THREE.MathUtils.degToRad(this.data.speed) * timeFactor);
            this.el.object3D.rotateOnWorldAxis(this.worldYAxis, step);
            this.selfRotation += step;
        },

        checkCompletion: function() {
            if (Math.abs(this.angle - this.targetAngle) > 0.001) return;

            // 位置对齐
            this.angle = this.targetAngle;
            this.el.object3D.position.set(
                this.center.x + this.data.radius * Math.cos(this.angle),
                this.el.object3D.position.y,
                this.center.z + this.data.radius * Math.sin(this.angle)
            );

            // 自转角度对齐
            const targetRot = Math.round(this.selfRotation / (Math.PI/2)) * (Math.PI/2);
            const adjust = targetRot - this.selfRotation;
            this.el.object3D.rotateOnWorldAxis(this.worldYAxis, adjust);
            this.selfRotation = targetRot;

            this.isMoving = false;
        }
    });

    // 全局事件监听
    document.addEventListener('DOMContentLoaded', () => {
        // 按键配置
        const keyConfig = {
            'q': { layer: 'top', direction: 1 },    // 顶层顺时针
            'e': { layer: 'top', direction: -1 },   // 顶层逆时针
            'z': { layer: 'bottom', direction: 1 }, // 底层顺时针
            'c': { layer: 'bottom', direction: -1 } // 底层逆时针
        };

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (!Object.keys(keyConfig).includes(key)) return;

            // 更新所有方块层级状态
            document.querySelectorAll('.cube').forEach(cube => {
                cube.components['cube-controller'].updateLayerStatus();
            });

            // 触发对应层级旋转
            document.querySelectorAll('.cube').forEach(cube => {
                const ctrl = cube.components['cube-controller'];
                if (!ctrl) return;

                const config = keyConfig[key];
                const isTargetLayer = config.layer === 'top' ?
                    ctrl.isTopLayer : ctrl.isBottomLayer;

                if (isTargetLayer) {
                    ctrl.handleRotation(config.direction);
                }
            });
        });
    });
</script>

<body style="margin: 0px; overflow: hidden;">
<a-scene
        embedded arjs="sourceType: webcam;" renderer="preserveDrawingBuffer: true;">
        <a-assets>
            <img id="my-image" src="../../image.png">
            <a-asset-item id="cube" src="/models/RBsCubeWorldOriginCube.glb"></a-asset-item>
        </a-assets>
    <a-marker preset="hiro">
        <a-entity class="RBsCube">

            <!-- 中心块（radius = 0）-->
            <a-gltf-model src="#cube" class="cube center" position="0 0 0" cube-controller="radius: 0"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 -1 0" cube-controller="radius: 0"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 1 0" cube-controller="radius: 0"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 0 1" cube-controller="radius: 0"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="1 0 0" cube-controller="radius: 0"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 0 -1" cube-controller="radius: 0"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="-1 0 0" cube-controller="radius: 0"></a-gltf-model>

            <!-- 棱块（radius = 1）-->
            <a-gltf-model src="#cube" class="cube edge" position="0 1 1" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 1 0" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="0 1 -1" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 1 0" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="0 -1 1" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 -1 0" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="0 -1 -1" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 -1 0" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 0 -1" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 0 -1" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 0 1" cube-controller="radius: 1"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 0 1" cube-controller="radius: 1"></a-gltf-model>

            <!-- 角块（radius = 1.414）-->
            <a-gltf-model src="#cube" class="cube corner" position="1 1 1" cube-controller="radius: 1.414"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 1 -1" cube-controller="radius: 1.414"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="1 1 -1" cube-controller="radius: 1.414"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 1 1" cube-controller="radius: 1.414"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="1 -1 1" cube-controller="radius: 1.414"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="1 -1 -1" cube-controller="radius: 1.414"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 -1 1" cube-controller="radius: 1.414"></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 -1 -1" cube-controller="radius: 1.414"></a-gltf-model>

        </a-entity>
    </a-marker>
    <a-entity camera></a-entity>

    <a-entity
            rbscube-controller
            position="2.5 -1.5 -8"
            scale="0.3 0.3 0.3"
            gltf-model="url(../models/RBsCubeWorldOrigin.glb)"
    >
    </a-entity>


    <a-text value="Dev Mode" position="-0.5 1 -10"></a-text>
    <a-text value="Press ''Q'' for testing" position="-1 0.5 -10"></a-text>
    <a-text value="(Hint: Hiro marker is available)" position="-1.5 0 -10"></a-text>
</a-scene>
</body>
</html>

